<task>
我需要根据量子计算中SWAP算符验证bell不等式保真度写一个代码，专门用于求解保真度方程，输出符号形式以及json文件。
1.该程序可以自行将可观测量转换为投影算子，$A = 2E - I, B = 2F - I$。
2.该程序需要计算并显式给出rho_swap矩阵（使用可观测量符号A0,A1,B0,B1表示）。
3.该程序可以基于rho_swap推导出保真度方程func F，并输出可观测量和投影算子两种符号表示。利用符号计算库（如 Python 的 SymPy），完成推导、代换、展开，最后把结果存成一个“系数表”json文件，此文件仅使用投影算子表示。利用 SymPy 定义非对易符号 $A_i, B_i$。构建 Yang & Navascués 的高级 SWAP 门表达式。关键步骤：在符号层面直接代入 $A = 2E - I, B = 2F - I$。展开多项式（Expand），合并同类项。将最终结果（形如 0.25 * "E0 F0" + ...）提取为字典，保存为 JSON 文件。
json格式如下：
{
  "E0 F0": 0.5403,
  "E1": -0.12,
  "I": 0.25
}
4.rho_swap和func的公式在上面已经给出。
5.输出的json文件保存在该代码的同级文件夹内的子文件夹“func”里面。
</task>

--子文件夹func【两个json】
fidelity_coeffs_obs.json
fidelity_coeffs.json

get_fidelity_func.py: 输出2个json文件，是保真度方程。未旋转情况【有错误，公式不对】
get_func1.py: 尝试修改。能输出json也能验证（结合了get和check）现在是1没错了。

check_fidelity_func.py: 验证observable形式的func是否正确。【对的
check_fidelity_func2.py: 验证projector形式的func是否正确。【对的

--子文件夹test_fun
split_projector.py: 把fidelity_coeffs.json的投影分成两份。【复制版放在外面了】


---主文件夹202512_sdp2
custom_new1.py: 完全笨方法求sdp。结果放在1219.
custom_new2.py: 改成输入alpha=0.5了
custom_new3.py: 还是输入alpha，画图从alpha+2到sqrt(8+2alpha^2)